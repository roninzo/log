package logger

// Logger flags; borrowed heavily from:
// https://github.com/gofiber/fiber/blob/master/middleware/logger/logger.go
//
// LreqHeader
// LrespHeader
// Llocals
// Lquery
// Lform
// Lcookie
// LBlack
// LRed
// LGreen
// LYellow
// LBlue
// LMagenta
// LCyan
// LWhite
// LReset
const (
	Lpid = 1 << iota
	Ltime
	Lreferer
	Lprotocol
	Lport
	LIP
	LIPs
	Lhost
	Lmethod
	Lpath
	LURL
	LUA
	Llatency
	Lstatus
	LresBody
	LqueryStringParams
	Lbody
	LbytesSent
	LbytesReceived
	Lroute
	Lerror
	Luid // Custom
	Lrid
	LstdFlags = Lpid | LIP | Luid | Lstatus | LbytesSent | Llatency | Lmethod | Lpath
)

// Tags
//
// LreqHeader:         "reqHeader:",
// LrespHeader:        "respHeader:",
// Llocals:            "locals:",
// Lquery:             "query:",
// Lform:              "form:",
// Lcookie:            "cookie:",
// LBlack:             "black",
// LRed:               "red",
// LGreen:             "green",
// LYellow:            "yellow",
// LBlue:              "blue",
// LMagenta:           "magenta",
// LCyan:              "cyan",
// LWhite:             "white",
// LReset:             "reset",
var Tags = map[int]string{
	Lpid:               "pid",
	Ltime:              "time",
	Lreferer:           "referer",
	Lprotocol:          "protocol",
	Lport:              "port",
	LIP:                "ip",
	LIPs:               "ips",
	Lhost:              "host",
	Lmethod:            "method",
	Lpath:              "path",
	LURL:               "url",
	LUA:                "ua",
	Llatency:           "latency",
	Lstatus:            "status",
	LresBody:           "resBody",
	LqueryStringParams: "query_string_params",
	Lbody:              "body",
	LbytesSent:         "bytes_sent",
	LbytesReceived:     "bytes_received",
	Lroute:             "route",
	Lerror:             "error",
	Luid:               "userid", // Custom
	Lrid:               "requestid",
}

// locals/query/form/reqHeader/respHeader/etc.
//
// default:
// 	// Check if we have a value tag i.e.: "reqHeader:x-key"
// 	switch {
// 	case strings.HasPrefix(tag, TagReqHeader):
// 		return buf.WriteString(c.Get(tag[10:]))
// 	case strings.HasPrefix(tag, TagHeader):
// 		return buf.WriteString(c.Get(tag[7:]))
// 	case strings.HasPrefix(tag, TagRespHeader):
// 		return buf.WriteString(c.GetRespHeader(tag[11:]))
// 	case strings.HasPrefix(tag, TagQuery):
// 		return buf.WriteString(c.Query(tag[6:]))
// 	case strings.HasPrefix(tag, TagForm):
// 		return buf.WriteString(c.FormValue(tag[5:]))
// 	case strings.HasPrefix(tag, TagCookie):
// 		return buf.WriteString(c.Cookies(tag[7:]))
// 	case strings.HasPrefix(tag, TagLocals):
// 		switch v := c.Locals(tag[7:]).(type) {
// 		case []byte:
// 			return buf.Write(v)
// 		case string:
// 			return buf.WriteString(v)
// 		case nil:
// 			return 0, nil
// 		default:
// 			return buf.WriteString(fmt.Sprintf("%v", v))
// 		}
// 	}
// }

// // These flags define which text to prefix to each log entry generated by the Logger.
// // Bits are or'ed together to control what's printed.
// // With the exception of the Lmsgprefix flag, there is no
// // control over the order they appear (the order listed here)
// // or the format they present (as described in the comments).
// // The prefix is followed by a colon only when Llongfile or Lshortfile
// // is specified.
// // For example, flags Ldate | Ltime (or LstdFlags) produce,
// //	2009/01/23 01:23:23 message
// // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
// //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
// const (
// 	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
// 	Ltime                         // the time in the local time zone: 01:23:23
// 	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
// 	Llongfile                     // full file name and line number: /a/b/c/d.go:23
// 	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
// 	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
// 	Lmsgprefix                    // move the "prefix" from the beginning of the line to before the message
// 	LstdFlags     = Ldate | Ltime // initial values for the standard logger
// )

// // Flags returns the output flags for the logger.
// // The flag bits are Ldate, Ltime, and so on.
// // SetFlags sets the output flags for the logger.
// // The flag bits are Ldate, Ltime, and so on.
// func (l *Logger) Flags(flag ...int) int {
// 	if len(flag) > 0 {
// 		l.flag = flag[0]
// 	}
// 	return l.flag
// }
